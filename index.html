<!DOCTYPE html>
<html lang="en">
<head>
    <title>BNGL Visualizer</title>
    <link rel="stylesheet" type="text/css" href="public/style.css"/>
</head>
<body>
<p><h1>BioNetGenLanguage (BNGL) code visualizer</h1></p>
<table>
  <tr>
    <td>
      <input id="bngl-file-input" type="file" oninput="visualize();" onclick="inputClick();">
    </td>
    <td id="canvas-cell">
      <canvas id="testCanvas"></canvas>
    </td>
    <td id="canvas-text">
      Molecule is shown as an oval ...
    </td>
  </tr>
</table>
<div id="canvas-container"></div>
<div id="table-container"></div>
<script src="public/model-graphics.js"></script>
<script src="public/bngl-extractor.js"></script>
<script>
  //set max dimensions for canvases (normally 4000, 180)
  window.maxWidth = 10000;
  window.maxHeight = 250;
  //set bngl begin tokens
  const compartmentTokens = ["compartments"];
  const moleculeTokens = [
    "molecule types",
    "molecular types",
    "molecule_types",
    "molecular_types"
  ];
  const speciesTokens = [
    "species",
    "seed species",
    "seed_species"
  ];
  const observablesTokens = ["observables"];
  const reactionTokens = ["reaction rules", "reaction_rules"];

  //get major elements
  const testCanvas = document.getElementById("testCanvas");
  const canvContain = document.getElementById("canvas-container");
  const tableContain = document.getElementById("table-container");
  const fileInput = document.getElementById("bngl-file-input");
  const body = document.body;

  //other global var declaration
  var allElms;
  var mm = new MoleculeManager();
  var be = new BNGLExtractor(mm);

  //manage ids
  class IDManager {
    constructor() {
      this.nextID = -1;
    }

    getID() {
      this.nextID++;
      return this.nextID;
    }
  }
  var idManager = new IDManager();

  //set mode to dark mode initially
  var darkMode = true;
  switchDarkMode(false);

  function switchDarkMode(actuallySwitch = true) {
    //recompile list of elms
    allElms = body.getElementsByTagName("*");
    let len = allElms.length;
    let oldClass, newClass;
    //switch mode
    if (actuallySwitch) {
      if (darkMode) {
        darkMode = false;
        oldClass = "dark-mode";
        newClass = "light-mode";
      } else {
        darkMode = true;
        oldClass = "light-mode";
        newClass = "dark-mode";
      }
    }
    //change css classes
    for (let i = 0; i < len; i++) {
      allElms[i].classList.remove(oldClass);
      allElms[i].classList.add(newClass);
    }
    //body must be completed sepratley
    body.classList.remove(oldClass);
    body.classList.add(newClass);
  }

  function capitalizeFirstLetter(s) {
    let words = s.split(" ");
    words.forEach((word, i) => {
      words[i] = word[0].toUpperCase() + word.slice(1, s.length);
    });
    return words.join(' ');
  }

  //draw test canvas
  testCanvas.width = window.maxWidth;
  testCanvas.height = window.maxHeight;
  drawBNGL('@EC:EGF(rb)', testCanvas);
  function testText() {
    testCanvas.width = 150;
    testCanvas.height = 50;
    let ctx = testCanvas.getContext("2d", { willReadFrequently: true });
    ctx.fillStyle = "#ffffff";
    ctx.font = "15px Arial";
    ctx.fillText(word, 0, 15);
    ctx.fillStyle = "#ff0000";
    let width = ctx.measureText(word).width;
    ctx.rect(0, 15, width, 1);
    ctx.fill();
  }
  //testText();

  //draw bngl
  function drawBNGL(bngl, canvas, data = {type: "molecules", drawExtraPlus: false}) {
    let drawExtraPlus = data.drawExtraPlus;
    let type = data.type;
    let compartmentMap = data.compartmentMap;
    //set up drawing context. "willReadFrequently: true" puts processes in GPU
    let ctx = canvas.getContext("2d", { willReadFrequently: true });
    let drawObj, compartment;
    let parameters = {
      mode: 'compact',
      darkMode: this.darkMode,
      compartmentMap: compartmentMap
    };
    if (type === "observables") {
      if (compartmentMap) {
        compartment = compartmentMap[bngl[0][0]];
        parameters["compDimension"] = mm.getDimension(compartment);
        parameters["compartment"] = compartment;
      }
      parameters["manager"] = mm;
      //should be [reactants, products, sign] but observables with - bond are in sign
      drawObj = new Graphic(bngl[0][0], parameters);
    } else if (type === "reactions") {
      [reactants, products, sign] = bngl;
      parameters["manager"] = mm;
      drawObj = new Reaction(reactants, products, sign, ctx, parameters);
    } else if (type === "species") {
      if (compartmentMap) {
        compartment = compartmentMap[bngl];
        parameters["compDimension"] = mm.getDimension(compartment);
        parameters["compartment"] = compartment;
      }
      parameters["manager"] = mm;
      drawObj = new Graphic(bngl, parameters);
    } else {
      if (compartmentMap) {
        compartment = compartmentMap[bngl];
        parameters["compDimension"] = mm.getDimension(compartment);
        parameters["compartment"] = compartment;
      }
      drawObj = new Graphic(bngl, parameters);
    }
    let reactionDims = drawObj.draw(ctx, 0, 0);
    //draw graphic
    drawObj.doDrawList();
    //get dimensions
    let dims;
    dims = getCanvasDimentions(ctx);
    //resize canvas
    canvas.width = dims[0];
    canvas.height = dims[1];
    //have to redraw
    drawObj.doDrawList();
    if ((type === "molecules" || type === "species") && !mm.has(drawObj)) {
      mm.addMolecule(drawObj);
    }
  }

  function standardizeElm(elm) {
    //create new html element for string inputs
    if (typeof elm == "string") {
      newP = document.createElement("p");
      newP.innerHTML = elm;
      elm = newP;
    }
    return elm;
  }

  function addElmLast(child, parent) {
    parent.appendChild(standardizeElm(child));
  }

  function addToTable(elmNestedList, table, colSpan=0) {
    //iterate through rows
    for (let rowNum = 0; rowNum < elmNestedList.length; rowNum++) {
      let row = elmNestedList[rowNum];
      //make new row
      let tempRow = document.createElement("tr");
      tempRow.classList.add("canvas-row");
      addElmLast(tempRow, table);
      //iterate though elements in row
      for (let elmNum = 0; elmNum < row.length; elmNum++) {
        let elm = standardizeElm(row[elmNum]);
        //if elm is list, there may be multiple elms to add
        let arrayMode = elm.length != undefined;
        let tempTD = document.createElement("td");
        if (colSpan) {
          tempTD.colSpan = colSpan;
        }
        if (colSpan) {
          tempTD.classList.add("divider-td");
        } else {
          tempTD.classList.add("main-td");
        }
        if (!arrayMode) {
          //insert single element into td
          addElmLast(elm, tempTD);
          addElmLast(tempTD, tempRow);
        } else {
          for (let i = 0; i < elm.length; i++) {
            //insert multiple elements into td
            addElmLast(elm[i], tempTD);
            addElmLast(tempTD, tempRow);
          }
        }
      }
    }
  }

  function separateBNGLNewLines(reactants, products, sign, newLines) {
    let signProcessed = false;
    function reformat(list) {
      if (!signProcessed) {
        if (list.length == 0) {
          return [[],[],null];
        }
        let i = 0;
        let elm = list[i];
        let noSign = true;
        while (true) {
          if (i >= list.length) {
            break;
          }
          if (elm == null || elm.includes("<") || elm.includes(">")) {
            noSign = false;
            signProcessed = true;
            break;
          }
          i++;
          elm = list[i];
        }
        return [
          list.slice(0, i),
          list.slice(i + 1, list.legnth),
          ((noSign) ? null : list[i])
        ];
      } else {
        return [[], list, null];
      }
    }
    function sliceNewLine(output, startIndex, index) {
      //combine reactants, sign, and product into 1 list to match newline index format
      let sliced = condensedList.slice(startIndex, index);
      //reformat() expands condensed list back into reactants, sign, and product
      output.push(reformat(sliced));
    }
    let condensedList;
    if (sign) {
      condensedList = reactants.concat([sign]).concat(products);
    } else {
      condensedList = reactants.concat(products);
    }
    let output = [];
    let rowNewLineIndexMap = {};
    let startIndex;
    let index = 0;
    for (let i = 0; i < newLines.length; i++) {
      startIndex = index;
      index = newLines[i].index;
      sliceNewLine(output, startIndex, index);
      rowNewLineIndexMap[output.length - 1] = i;
    }
    sliceNewLine(output, index, condensedList.length);
    //remove empty lists
    for (let i = 0; i < output.length; i++) {
      let row = output[i];
      if (row[0].length == 0 && row[1].length == 0 && !row[2]) {
        output.splice(i, 1);
        newLines.splice(rowNewLineIndexMap[i], 1);
      }
    }
    return output;
  }

  //render one set (need to add compartments)
  function prepareRow(data, type) {
    let molcCompMap = {};
    let bngl, conc, comment, name, compartment;
    if (type != "reactions" && type != "observables" && type != "compartments") {
      bngl = data.bngl;
      conc = data.conc.trim();
      comment = data.comment.trim();
      observType = data.observType;
      [bngl, compartment] = mm.processMoleculeCompartment(bngl.trim());
      if (compartment) {
        bngl = "@" + compartment + ":" + addBNGLParenthesis(bngl);
      } else {
        bngl = addBNGLParenthesis(bngl);
      }
      molcCompMap[bngl] = compartment;
      //get name (change this to only after parenthesis)
      name = bngl.split("(")[0];
      var bngls = [bngl];
    } else if (type == "compartments") {
      //add compartments to molecule manager
      mm.addCompartment(data.name, data.dimension);
      return Object.values(data);
    } else if (type == "observables") {
      [reactants, products, sign, observData, comment, newLines] = Object.values(data);
      //add paranthesis if there are none
      let bngl, compartment;
      reactants.forEach((item, i) => {
        [bngl, compartment] = mm.processMoleculeCompartment(item)
        reactants[i] = addBNGLParenthesis(bngl);
        molcCompMap[bngl] = compartment;
      });
      var bngls = separateBNGLNewLines(reactants, products, sign, newLines);
    } else if (type === "reactions") {
      [reactants, products, sign, rate, comment, newLines] = Object.values(data);
      //add paranthesis if there are none
      let bngl, compartment;
      reactants.forEach((item, i) => {
        [bngl, compartment] = mm.processMoleculeCompartment(item)
        reactants[i] = addBNGLParenthesis(bngl);
        molcCompMap[bngl] = compartment;
      });
      products.forEach((item, i) => {
        [bngl, compartment] = mm.processMoleculeCompartment(item)
        products[i] = addBNGLParenthesis(bngl);
        molcCompMap[bngl] = compartment;
      });
      var bngls = separateBNGLNewLines(reactants, products, sign, newLines);
    }
    //handle new line special case
    let hasNewLines = ((bngls.length > 1) ? true : false);

    //make canvases
    let newCans = [];
    for(let i = 0; i < bngls.length; i++) {
      bngl = bngls[i];
      bngl = bngl;
      //create new canvas
      let newCan = document.createElement("canvas");
      newCans.push(newCan);
      //must have inital dimensions as large as largest possible visualization
      newCan.width = window.maxWidth;
      newCan.height = window.maxHeight;
      newCan.classList.add("bngl-canvas");
      //draw object on canvas
      drawBNGL(
        bngl,
        newCan,
        {
          type: type,
          compartmentMap: molcCompMap,
          drawExtraPlus: hasNewLines && i < bngls.length - 1
        }
      );
    }
    //output as list
    if (type == "species") {
      return [name, newCans, bngl, conc, comment];
    } else if (type == "observables") {
      return [
        observData.type,
        observData.name,
        newCans,
        be.compileBNGL(data, type, observData.type),
        comment
      ];
    } else if (type == "reactions") {
      return [
        be.compileBNGL(data),
        newCans,
        rate,
        comment
      ];
    } else {
      return [name, newCans, bngl, comment];
    }
  }

  //render 1 type (molecules, species, etc)
  function visualizeType(type, list) {
    //add new table
    let newTable = document.createElement("table");
    addElmLast(newTable, tableContain);
    //render header
    if (type != "header comments" || list.length > 0) {
      addToTable([[document.createElement("hr")]], newTable, 5);
      const newDivider = document.createElement("p");
      if (type != "header comments") {
        newDivider.innerHTML = capitalizeFirstLetter(type);
      }
      newDivider.classList.add("table-divider");
      addToTable([[newDivider]], newTable, 5);
      if (type == "observables") {
        addToTable(
          [['Type', 'Name', 'Visualization', 'BNGL code', 'Comment']],
          newTable
        );
      } else if (type == "molecules") {
        addToTable(
          [['Name', 'Visualization', 'BNGL code', 'Comment']],
          newTable
        );
      } else if (type == "reactions") {
        addToTable(
          [['BNGL code', 'Visualization', 'Rate', 'Comment']],
          newTable
        );
      } else if (type == "compartments") {
        addToTable(
          [['Name', 'Dimension', 'Size', 'Comment']],
          newTable
        );
      } else if (type != "header comments") {
        addToTable(
          [['Name', 'Visualization', 'BNGL code', 'Concentration', 'Comment']],
          newTable
        );
      }
      //render rows
      if (list.length > 0) {
        let output = [];
        for (let i = 0; i < list.length; i++) {
          item = list[i];
          //normal row
          if (typeof item == "object") {
            addToTable([prepareRow(item, type)], newTable);
          }
          //full line comment
          else if (typeof item == "string") {
            addToTable([[item]], newTable, 5);
          }
        }
      } else {
        addToTable([["None", "", "", ""]], newTable);
      }
    }
  }

  //render everything in bngl
  function visualize() {
    //remove all old visualizations
    //remove everything in table
    let oldElms = tableContain.children;
    let numOldElms = oldElms.length;
    for(let i = 0; i < numOldElms; i++) {
      oldElms[0].remove();
    }
    //remove everything in canvas div
    oldElms = canvContain.children;
    numOldElms = oldElms.length;
    for(let i = 0; i < numOldElms; i++) {
      oldElms[0].remove();
    }
    //reset molecule manager
    mm.reset();
    //render new file
    var bnglFile = fileInput.files[0];
    reader = new FileReader();
    reader.onload = () => {
      let bngl = reader.result;
      //process all things of intrest
      comments = be.extractComments(bngl);
      compartments = be.extractBNGL(bngl, compartmentTokens, "compartments");
      molecules = be.extractBNGL(bngl, moleculeTokens);
      species = be.extractBNGL(bngl, speciesTokens);
      observables = be.extractBNGL(bngl, observablesTokens, "observable");
      reactions = be.extractBNGL(bngl, reactionTokens, "reaction");
      //visualize everything
      visualizeType("header comments", comments);
      visualizeType("compartments", compartments);
      visualizeType("molecules", molecules);
      visualizeType("species", species);
      visualizeType("observables", observables);
      visualizeType("reactions", reactions);
      //make arrows bigger
      let pElms = document.querySelectorAll("p");
      for (let i = 0; i < pElms.length; i++) {
        let elm = pElms[i];
        elm.innerHTML = elm.innerHTML.replace("&lt;-&gt;", ' <span class="big-arrow">&#8596;</span> ');
        elm.innerHTML = elm.innerHTML.replace("-&gt;", ' <span class="big-arrow">&#8594;</span> ');
        elm.innerHTML = elm.innerHTML.replace("&lt;-", ' <span class="big-arrow">&#8592;</span> ');
      };

    }
    //read if file present
    if (fileInput.value) {
      reader.readAsText(bnglFile);
    }
  }

  //function to reset input element value when it is clicked
  //this is needed because chrome doesn't trigger onchange if filename is same
  function inputClick() {
    fileInput.value = "";
  }
</script>
</body>
</html>
