<p><h1>BioNetGenLanguage (BNGL) code visualizer</h1></p>
<table>
  <tr>
    <td>
      <input id="bngl-file-input" type="file" onchange="visualize()">
    </td>
    <td id="canvas-cell">
      <canvas id="testCanvas" width="4000" height="180"></canvas>
    </td>
    <td id="canvas-text">
      Molecule is shown as an oval ...
    </td>
  </tr>
</table>
<div id="canvas-container"></div>
<div id="table-container"></div>
<script src="/model-graphics.js"></script>
<script src="/bngl-extractor.js"></script>
<script>
  //set bngl begin tokens
  const compartmentTokens = ["compartments"];
  const moleculeTokens = [
    "molecule types",
    "molecular types",
    "molecule_types",
    "molecular_types"
  ];
  const speciesTokens = [
    "species",
    "seed species",
    "seed_species"
  ];
  const observablesTokens = ["observables"];
  const reactionTokens = ["reaction rules", "reaction_rules"];

  //get major elements
  const testCanvas = document.getElementById("testCanvas");
  const canvContain = document.getElementById("canvas-container");
  const tableContain = document.getElementById("table-container");
  const fileInput = document.getElementById("bngl-file-input");
  const body = document.body;

  //other global var declaration
  var oldFileInputValue = "";
  var allElms;
  var mm = new MoleculeManager();
  var be = new BNGLExtractor();

  //set mode to dark mode initially
  var darkMode = true;
  switchDarkMode(false);

  function switchDarkMode(actuallySwitch = true) {
    //recompile list of elms
    allElms = body.getElementsByTagName("*");
    let len = allElms.length;
    let oldClass, newClass;
    //switch mode
    if (actuallySwitch) {
      if (darkMode) {
        darkMode = false;
        oldClass = "dark-mode";
        newClass = "light-mode";
      } else {
        darkMode = true;
        oldClass = "light-mode";
        newClass = "dark-mode";
      }
    }
    //change css classes
    for (let i = 0; i < len; i++) {
      allElms[i].classList.remove(oldClass);
      allElms[i].classList.add(newClass);
    }
    //body must be completed sepratley
    body.classList.remove(oldClass);
    body.classList.add(newClass);
  }

  function capitalizeFirstLetter(s) {
    let words = s.split(" ");
    words.forEach((word, i) => {
      words[i] = word[0].toUpperCase() + word.slice(1, s.length);
    });
    return words.join(' ');
  }

  //draw test canvas
  drawBNGL('z(a)', testCanvas);

  //draw bngl
  function drawBNGL(bngl, canvas, type = "", drawExtraPlus = false) {
    //set up drawing context. "willReadFrequently: true" puts processes in GPU
    let ctx = canvas.getContext("2d", { willReadFrequently: true });
    let drawObj;
    if (type === "observables") {
      let parameters = {
        mode: 'compact',
        darkMode: this.darkMode,
        manager: mm
      };
      drawObj = new Graphic(bngl[0][0], parameters);
    } else if (type === "reactions") {
      [reactants, products, sign] = bngl;
      let parameters = {
        drawExtraPlus: drawExtraPlus,
        darkMode: this.darkMode,
        manager: mm
      };
      drawObj = new Reaction(reactants, products, sign, ctx, parameters);
    } else {
      let parameters = {
        mode: 'compact',
        darkMode: this.darkMode
      };
      drawObj = new Graphic(bngl, parameters);
    }
    let reactionDims = drawObj.draw(ctx, 0, 0);
    //draw graphic
    drawObj.doDrawList();
    //get dimensions
    let dims;
    if (type === "reactions") {
      //dims = reactionDims;
      dims = getCanvasDimentions(ctx);
    } else {
      dims = getCanvasDimentions(ctx);
    }
    //resize canvas
    canvas.width = dims[0];
    canvas.height = dims[1];
    //have to redraw
    drawObj.doDrawList();
    if ((type === "molecules" || type === "species") && !mm.has(drawObj)) {
      mm.addMolecule(drawObj);
    }
  }

  function standardizeElm(elm) {
    //create new html element for string inputs
    if (typeof elm == "string") {
      newP = document.createElement("p");
      newP.innerHTML = elm;
      elm = newP;
    }
    return elm;
  }

  function addElmLast(child, parent) {
    parent.appendChild(standardizeElm(child));
  }

  function addToTable(elmNestedList, table, colSpan=0) {
    //iterate through rows
    for (let rowNum = 0; rowNum < elmNestedList.length; rowNum++) {
      let row = elmNestedList[rowNum];
      //make new row
      let tempRow = document.createElement("tr");
      tempRow.classList.add("canvas-row");
      addElmLast(tempRow, table);
      //iterate though elements in row
      for (let elmNum = 0; elmNum < row.length; elmNum++) {
        let elm = standardizeElm(row[elmNum]);
        //if elm is list, there may be multiple elms to add
        let arrayMode = elm.length != undefined;
        let tempTD = document.createElement("td");
        if (colSpan) {
          tempTD.colSpan = colSpan;
        }
        if (colSpan) {
          tempTD.classList.add("divider-td");
        } else {
          tempTD.classList.add("main-td");
        }
        if (!arrayMode) {
          //insert single element into td
          addElmLast(elm, tempTD);
          addElmLast(tempTD, tempRow);
        } else {
          for (let i = 0; i < elm.length; i++) {
            //insert multiple elements into td
            addElmLast(elm[i], tempTD);
            addElmLast(tempTD, tempRow);
          }
        }
      }
    }
  }

  function separateBNGLNewLines(reactants, products, sign, newLines) {
    let signProcessed = false;
    function reformat(list) {
      if (!signProcessed) {
        if (list.length == 0) {
          return [[],[],null];
        }
        let i = 0;
        let elm = list[i];
        let noSign = true;
        while (true) {
          if (i >= list.length) {
            break;
          }
          if (elm == null || elm.includes("-")) {
            noSign = false;
            signProcessed = true;
            break;
          }
          i++;
          elm = list[i];
        }
        return [
          list.slice(0, i),
          list.slice(i + 1, list.legnth),
          ((noSign) ? null : list[i])
        ];
      } else {
        return [[], list, null];
      }
    }
    function sliceNewLine(output, startIndex, index) {
      //combine reactants, sign, and product into 1 list to match newline index format
      let sliced = condensedList.slice(startIndex, index);
      //reformat() expands condensed list back into reactants, sign, and product
      output.push(reformat(sliced));
    }
    let condensedList;
    if (sign) {
      condensedList = reactants.concat([sign]).concat(products);
    } else {
      condensedList = reactants.concat(products);
    }
    let output = [];
    let startIndex;
    let index = 0;
    for (let i = 0; i < newLines.length; i++) {
      startIndex = index;
      index = newLines[i].index;
      sliceNewLine(output, startIndex, index);
    }
    sliceNewLine(output, index, condensedList.length);
    return output;
  }

  //render one set (need to add compartments)
  function prepareRow(data, type) {
    let bngl, conc, comment, name;
    if (type != "reactions" && type != "observables" && type != "compartments") {
      [bngl, conc, comment, observType] = Object.values(data);
      comment = comment.trim();
      bngl = mm.processMoleculeCompartment(bngl.trim());
      conc = conc.trim();
      var bngls = [bngl];
      //add paranthesis if there are none
      bngl = addBNGLParenthesis(bngl);
      //get name (change this to only after parenthesis)
      if (type != "observables") {
        name = bngl.split("(")[0];
      }
    } else if (type == "compartments") {
      //add compartments to molecule manager
      mm.addCompartment(data.name, data.dimension);
      return Object.values(data);
    } else if (type == "observables") {
      [reactants, products, sign, observData, comment, newLines] = Object.values(data);
      //add paranthesis if there are none
      reactants.forEach((item, i) => {
        reactants[i] = addBNGLParenthesis(mm.processMoleculeCompartment(item));
      });
      var bngls = separateBNGLNewLines(reactants, products, sign, newLines);
    } else if (type === "reactions") {
      [reactants, products, sign, rate, comment, newLines] = Object.values(data);
      //add paranthesis if there are none
      reactants.forEach((item, i) => {
        reactants[i] = addBNGLParenthesis(mm.processMoleculeCompartment(item));
      });
      products.forEach((item, i) => {
        products[i] = addBNGLParenthesis(mm.processMoleculeCompartment(item));
      });
      var bngls = separateBNGLNewLines(reactants, products, sign, newLines);
    }
    //handle new line special case
    let hasNewLines = ((bngls.length > 1) ? true : false);

    //make canvases
    let newCans = [];
    for(let i = 0; i < bngls.length; i++) {
      bngl = bngls[i];
      //create new canvas
      let newCan = document.createElement("canvas");
      newCans.push(newCan);
      //must have inital dimensions as large as largest possible visualization
      newCan.width = "4000";
      newCan.height = "180";
      newCan.classList.add("bngl-canvas");
      //draw object on canvas
      drawBNGL(bngl, newCan, type, hasNewLines && i < bngls.length - 1);
    }
    //output as list
    if (type == "species") {
      return [name, newCans, bngl, conc, comment];
    } else if (type == "observables") {
      //return [observType, name, newCans, bngl, comment];
      return [
        observData.type,
        observData.name,
        newCans,
        be.compileBNGL(data, type, observData.type),
        comment
      ];
    } else if (type == "reactions") {
      return [
        be.compileBNGL(data),
        newCans,
        rate,
        comment
      ];
    } else {
      return [name, newCans, bngl, comment];
    }
  }

  //render 1 type (molecules, species, etc)
  function visualizeType(type, list) {
    //add new table
    let newTable = document.createElement("table");
    addElmLast(newTable, tableContain);
    //render header
    if (type != "header comments" || list.length > 0) {
      addToTable([[document.createElement("hr")]], newTable, 5);
      const newDivider = document.createElement("p");
      newDivider.innerHTML = capitalizeFirstLetter(type);
      newDivider.classList.add("table-divider");
      addToTable([[newDivider]], newTable, 5);
      if (type == "observables") {
        addToTable(
          [['Type', 'Name', 'Visualization', 'BNGL code', 'Comment']],
          newTable
        );
      } else if (type == "molecules") {
        addToTable(
          [['Name', 'Visualization', 'BNGL code', 'Comment']],
          newTable
        );
      } else if (type == "reactions") {
        addToTable(
          [['BNGL code', 'Visualization', 'Rate', 'Comment']],
          newTable
        );
      } else if (type == "compartments") {
        addToTable(
          [['Name', 'Dimension', 'Size', 'Comment']],
          newTable
        );
      } else if (type != "header comments") {
        addToTable(
          [['Name', 'Visualization', 'BNGL code', 'Concentration', 'Comment']],
          newTable
        );
      }
      //render rows
      if (list.length > 0) {
        let output = [];
        for (let i = 0; i < list.length; i++) {
          item = list[i];
          //normal row
          if (typeof item == "object") {
            addToTable([prepareRow(item, type)], newTable);
          }
          //full line comment
          else if (typeof item == "string") {
            addToTable([[item]], newTable, 5);
          }
        }
      } else {
        addToTable([["None", "", "", ""]], newTable);
      }
    }
  }

  //render everything in bngl
  function visualize() {
    //remove all old visualizations
    let fileHasChanged = fileInput.value != oldFileInputValue;
    oldFileInputValue = fileInput.value;
    //remove everything in table
    let oldElms = tableContain.children;
    let numOldElms = oldElms.length;
    for(let i = 0; i < numOldElms; i++) {
      oldElms[0].remove();
    }
    //remove everything in canvas div
    oldElms = canvContain.children;
    numOldElms = oldElms.length;
    for(let i = 0; i < numOldElms; i++) {
      oldElms[0].remove();
    }
    //reset molecule manager
    mm.reset();
    //render new file
    var bnglFile = fileInput.files[0];
    reader = new FileReader();
    reader.onload = () => {
      let bngl = reader.result;
      //process all things of intrest
      comments = be.extractComments(bngl);
      compartments = be.extractBNGL(bngl, compartmentTokens, "compartments");
      molecules = be.extractBNGL(bngl, moleculeTokens);
      species = be.extractBNGL(bngl, speciesTokens);
      observables = be.extractBNGL(bngl, observablesTokens, "observable");
      reactions = be.extractBNGL(bngl, reactionTokens, "reaction");
      //visualize everything
      visualizeType("header comments", comments);
      visualizeType("compartments", compartments);
      visualizeType("molecules", molecules);
      visualizeType("species", species);
      visualizeType("observables", observables);
      visualizeType("reactions", reactions);
      console.log(mm);
      //make arrows bigger
      let pElms = document.querySelectorAll("p");
      for (let i = 0; i < pElms.length; i++) {
        let elm = pElms[i];
        elm.innerHTML = elm.innerHTML.replace("&lt;-&gt;", ' <span class="big-arrow">&#8596;</span> ');
        elm.innerHTML = elm.innerHTML.replace("-&gt;", ' <span class="big-arrow">&#8594;</span> ');
        elm.innerHTML = elm.innerHTML.replace("&lt;-", ' <span class="big-arrow">&#8592;</span> ');
      };

    }
    //read if file present
    if (fileInput.value) {
      reader.readAsText(bnglFile);
    }
  }
</script>
