<p><h1>BioNetGenLanguage (BNGL) code visualizer</h1></p>
<table>
  <tr>
    <td>
      <input id="bngl-file-input" type="file" onchange="visualize()">
    </td>
    <td id="canvas-cell">
      <canvas id="testCanvas" width="500" height="180"></canvas>
    </td>
    <td id="canvas-text">
      Molecule is shown as an oval ...
    </td>
  </tr>
</table>
<div id="canvas-container"></div>
<table id="canvas-table"></table>
<script src="/model-graphics.js"></script>
<script>
  //set bngl begin tokens
  const moleculeTokens = ["molecule types", "molecular types"];
  const speciesTokens = ["species", "seed species"];
  const observablesTokens = ["observables"];
  const reactionTokens = ["reaction rules"];

  //get major elements
  const testCanvas = document.getElementById("testCanvas");
  const canvContain = document.getElementById("canvas-container");
  const canvTable = document.getElementById("canvas-table");
  const fileInput = document.getElementById("bngl-file-input");
  var oldFileInputValue = "";

  var isWhitespace = (s) => {
    return /\s/.test(s);
  }

  var isNotWhitespace = (s) => {
    return !isWhitespace(s);
  }

  //draw test canvas
  drawBNGL('Molecule(site1~state1,site1)', testCanvas);

  //draw bngl
  function drawBNGL(bngl, canvas) {
    //set up drawing context. "willReadFrequently: true" puts processes in GPU
    let ctx = canvas.getContext("2d", { willReadFrequently: true });
    var drawObj = new Graphic(bngl, "compact");
    drawObj.draw(ctx, 0, 0);
    //draw graphic
    drawObj.doDrawList();
    let dims = getCanvasDimentions(ctx);
    //resize canvas
    canvas.width = dims[0];
    canvas.height = dims[1];
    //have to redraw
    drawObj.doDrawList();
  }

  //remove item from array
  function arrayRemove(arr, value) {
    var index = arr.indexOf(value);
    if (index > -1) {
      arr.splice(index, 1);
    }
    return arr;
  }

  function standardizeElm(elm) {
    //create new html element for string inputs
    if (typeof elm == "string") {
      newP = document.createElement("p");
      newP.innerHTML = elm;
      elm = newP;
    }
    return elm;
  }

  function addElmLast(child, parent) {
    parent.appendChild(standardizeElm(child));
  }

  function addToTable(elmNestedList, table, colSpan=0) {
    //iterate through rows
    for (let rowNum = 0; rowNum < elmNestedList.length; rowNum++) {
      let row = elmNestedList[rowNum];
      //make new row
      let tempRow = document.createElement("tr");
      tempRow.classList.add("canvas-row");
      addElmLast(tempRow, table);
      //iterate though elements in row
      for (let elmNum = 0; elmNum < row.length; elmNum++) {
        let elm = standardizeElm(row[elmNum]);
        //insert elm into row
        let tempTD = document.createElement("td");
        if (colSpan) {
          tempTD.colSpan = colSpan;
        }
        if (colSpan) {
          tempTD.classList.add("divider-td");
        } else {
          tempTD.classList.add("main-td");
        }
        addElmLast(elm, tempTD);
        addElmLast(tempTD, tempRow);
      }
    }
  }

  //next occurance of char in string
  function nextOccur(string, index, boolExpr, backwards = false, mod = 0) {
    let len = string.length;
    let direction;
    if (backwards) {
      direction = -1;
    } else {
      direction = 1;
    }
    while (index < len && index >= 0) {
      if (boolExpr(string[index])) {
        return index + mod;
      }
      index += direction;
    }
    return ((backwards) ? -1: len);
  }

  //might need to add case for when comment immdiatley follows conc
  //^ I do, see toy1 (1).bngl
  function extractSingleLineBNGL(s, type="") {
    //initialize vars
    let c = 0;
    let len = s.length;
    let char = null;
    let bnglStart = null;
    let bnglEnd = null;
    let concStart = null;
    let concEnd = null;
    let commStart = null;
    let commEnd = null;
    let readType = ((type == "observable") ? false : true);
    //parse
    while (c < len) {
      char = s[c];
      //is comment
      if (char == "#") {
        commStart = c + 1;
        commEnd = len - 1;
        break;
      }
      //starts with number
      if ((bnglStart == null) && (!isNaN(parseFloat(char)))) {
        c = nextOccur(s, c, isWhitespace);
        continue;
      }
      //is whitespace
      if (isWhitespace(char)) {
        c = nextOccur(s, c, isNotWhitespace);
        continue;
      }
      //is observable type
      if ((!readType) && (!bnglEnd) && isNotWhitespace(char) && (char != "#")) {
        readType = true;
        c = nextOccur(s, c, isWhitespace);
        continue;
      }
      //is non-whitespace and non-comment
      if ((!bnglEnd) && isNotWhitespace(char) && (char != "#")) {
        bnglStart = c;
        c = nextOccur(s, c, isWhitespace, false, -1);
        bnglEnd = c;
        c++;
        continue;
      }
      //start concentration
      if (bnglEnd && isNotWhitespace(char) && (char != "#")) {
        concStart = c;
        c = nextOccur(s, c, isWhitespace, false, -1);
        concEnd = c;
      }
      //if at end
      if (c == len - 1) {
        break;
      }
      c++;
    }
    let bngl = s.slice(bnglStart, bnglEnd + 1);
    let conc = s.slice(concStart, concEnd + 1);
    let comment = s.slice(commStart, commEnd + 1);
    return [
      ((bnglStart == null) ? "" : bngl),
      ((concStart == null) ? "" : conc),
      ((commStart == null) ? "" : comment),
    ];
  }

  function extractSingleLineReaction(s) {
    console.log(s);
    //initialize vars
    let c = 0;
    let len = s.length;
    let char;
    let bngls = [];
    let concs = [];
    let comment = "";
    //parse
    while (c < len) {
      char = s[c];
      //is comment
      if (char == "#") {
        comment = s.slice(c + 1, len);
        break;
      }
      //starts with number
      if ((bngls.length == 0) && (!isNaN(parseFloat(char)))) {
        c = nextOccur(s, c, isWhitespace);
        continue;
      }
      //is whitespace
      if (isWhitespace(char)) {
        c = nextOccur(s, c, isNotWhitespace);
        continue;
      }
      //is non-whitespace and non-comment
      if ((bngls.length == 0) && isNotWhitespace(char) && (char != "#")) {
        let n = nextOccur(s, c, isWhitespace, false, -1);
        bngls.push(s.slice(c, n + 1));
        c = n + 1;
        continue;
      }
      //start concentration
      if ((bngls.length != 0) && isNotWhitespace(char) && (char != "#")) {
        let n = nextOccur(s, c, isWhitespace, false, -1);
        concs.push(s.slice(c, n + 1));
        c = n;
      }
      //if at end
      if (c == len - 1) {
        break;
      }
      c++;
    }
    return [
      bngls.toString(),
      concs.toString(),
      comment
    ];
  }

  //extract bngl element
  function extractBNGL(bnglStr, elmStrList, type="") {
    let bngls = [];
    let toDelete = [];
    for (let i = 0; i < elmStrList.length; i++) {
      let elmStr = elmStrList[i];
      let beginToken = "begin " + elmStr;
      let startIndex = bnglStr.indexOf(beginToken);
      if (startIndex >= 0) {
        //find first new line
        let nlDist = 0;
        while (bnglStr[startIndex + beginToken.length + nlDist] != "\n") {
          nlDist += 1;
        }
        //split by line
        let endIndex = bnglStr.indexOf("\n" + "end " + elmStr);
        let sliced = bnglStr.slice(
          startIndex + nlDist + beginToken.length + 1,
          endIndex
        );
        bngls = bngls.concat(sliced.split("\n"));
        //clean list
        for (let u = 0; u < bngls.length; u++) {
          let bnglConcPair;
          if (type == "reaction") {
            bnglConcPair = extractSingleLineReaction(bngls[u]);
          } else {
            bnglConcPair = extractSingleLineBNGL(bngls[u], type);
          }
          bngls[u] = bnglConcPair;
          //mark empty strings for deletion
          if (!bngls[u][0].trim()) {
            toDelete.push(bngls[u]);
          }
        }
        //if begin token not found
        } else {
          continue;
        }
      }
      //delete empty strings
      for (let u = 0; u < toDelete.length; u++) {
        arrayRemove(bngls, toDelete[u]);
      }
      return bngls;
  }

  //render one set (need to add compartments)
  function prepareRow(bnglConcPair, title, includeConc=false) {
    let bngl, conc, comment;
    [bngl, conc, comment] = bnglConcPair;
    bngl = bngl.trim();
    conc = conc.trim();
    comment = comment.trim();
    //add paranthesis if there are none
    if (bngl.indexOf("(") < 0) {
      bngl = bngl + "()";
    }
    //get name (change this to only after parenthesis)
    let name = bngl.split("(")[0];
    //create new canvas
    const newCan = document.createElement("canvas");
    newCan.id = title;
    newCan.width = "500";
    newCan.height = "180";
    newCan.classList.add("bngl-canvas");
    //draw object on canvas
    drawBNGL(bngl, newCan);
    //output as list
    if (includeConc) {
      return [name, newCan, bngl, conc, comment];
    } else {
      return [name, newCan, bngl, "", comment];
    }
  }

  //render everything in bngl
  function visualize() {
    //remove all old visualizations
    let fileHasChanged = fileInput.value != oldFileInputValue;
    oldFileInputValue = fileInput.value;
    //remove everything in table
    let oldElms = canvTable.children;
    let numOldElms = oldElms.length;
    for(let i = 0; i < numOldElms; i++) {
      oldElms[0].remove();
    }
    //remove everything in canvas div
    oldElms = canvContain.children;
    numOldElms = oldElms.length;
    for(let i = 0; i < numOldElms; i++) {
      oldElms[0].remove();
    }
    var bnglFile = fileInput.files[0];
    reader = new FileReader();
    reader.onload = () => {
      let bngl = reader.result;
      //process all things of intrest
      molecules = extractBNGL(bngl, moleculeTokens);
      species = extractBNGL(bngl, speciesTokens);
      observables = extractBNGL(bngl, observablesTokens, "observable");
      //reactions = extractBNGL(bngl, reactionTokens, "reaction");
      reactions = [];
      //add header
      const nameHeader = document.createElement("h3");
      nameHeader.innerHTML = "Name";
      nameHeader.classList.add("bngl-header");
      const visualHeader = document.createElement("h3");
      visualHeader.innerHTML = "Visualization";
      visualHeader.classList.add("bngl-header");
      const BNGLHeader = document.createElement("h3");
      BNGLHeader.innerHTML = "BNGL code";
      BNGLHeader.classList.add("bngl-header");
      const concHeader = document.createElement("h3");
      concHeader.innerHTML = "Concentration";
      concHeader.classList.add("bngl-header");
      const commentHeader = document.createElement("h3");
      commentHeader.innerHTML = "Comment";
      commentHeader.classList.add("bngl-header");
      addToTable(
        [[nameHeader, visualHeader, BNGLHeader, concHeader, commentHeader]],
        canvTable
      );
      //render molecules
      const moleculeDivider = document.createElement("p");
      moleculeDivider.innerHTML = "Molecules";
      moleculeDivider.classList.add("table-divider");
      addToTable([[moleculeDivider]], canvTable, 5);
      if (molecules.length > 0) {
        let molcList = [];
        for (let i = 0; i < molecules.length; i++) {
          molcList.push(prepareRow(molecules[i], "molecules" + i));
        }
        addToTable(molcList, canvTable);
      } else {
        addToTable([["None", "", "", ""]], canvTable);
      }
      //render species
      const scDivider = document.createElement("p");
      scDivider.innerHTML = "Species";
      scDivider.classList.add("table-divider");
      addToTable([[scDivider]], canvTable, 5);
      if (species.length > 0) {
        let specList = [];
        for (let i = 0; i < species.length; i++) {
          specList.push(prepareRow(species[i], "species" + i, true));
        }
        addToTable(specList, canvTable);
      } else {
        addToTable([["None", "", "", ""]], canvTable);
      }
      //render observables
      const obsDivider = document.createElement("p");
      obsDivider.innerHTML = "Observables";
      obsDivider.classList.add("table-divider");
      addToTable([[obsDivider]], canvTable, 5);
      if (observables.length > 0) {
        let obsList = [];
        for (let i = 0; i < observables.length; i++) {
          obsList.push(prepareRow(observables[i], "observables" + i));
        }
        addToTable(obsList, canvTable);
      } else {
        addToTable([["None", "", "", ""]], canvTable);
      }
      //render reactions
      const reacDivider = document.createElement("p");
      reacDivider.innerHTML = "Reactions";
      reacDivider.classList.add("table-divider");
      addToTable([[reacDivider]], canvTable, 5);
      if (reactions.length > 0) {
        let reacList = [];
        for (let i = 0; i < reactions.length; i++) {
          reacList.push(prepareRow(reactions[i], "reactions" + i));
        }
        addToTable(reacList, canvTable);
      } else {
        addToTable([["None", "", "", ""]], canvTable);
      }
    }
    //read if file present
    if (fileInput.value) {
      reader.readAsText(bnglFile);
    }
  }
</script>
