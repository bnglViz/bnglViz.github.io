<p><h1>BioNetGenLanguage (BNGL) code visualizer</h1></p>
<table>
  <tr>
    <td>
      <input id="bngl-file-input" type="file" onchange="visualize()">
    </td>
    <td id="canvas-cell">
      <canvas id="testCanvas" width="500" height="180"></canvas>
    </td>
    <td id="canvas-text">
      Molecule is shown as an oval ...
    </td>
  </tr>
</table>
<div id="canvas-container"></div>
<table id="canvas-table"></table>
<script src="/model-graphics.js"></script>
<script>
  //set bngl begin tokens
  const moleculeTokens = ["molecule types", "molecular types"];
  const speciesTokens = ["species", "seed species"];
  const observablesTokens = ["observables"];
  const reactionTokens = ["reaction rules"];

  //get major elements
  const testCanvas = document.getElementById("testCanvas");
  const canvContain = document.getElementById("canvas-container");
  const canvTable = document.getElementById("canvas-table");
  const fileInput = document.getElementById("bngl-file-input");
  const body = document.body;

  //other global var declaration
  var oldFileInputValue = "";
  var allElms;

  //set mode to dark mode initially
  var darkMode = true;
  switchDarkMode(false);

  function switchDarkMode(actuallySwitch = true) {
    //recompile list of elms
    allElms = body.getElementsByTagName("*");
    let len = allElms.length;
    let oldClass, newClass;
    //switch mode
    if (actuallySwitch) {
      if (darkMode) {
        darkMode = false;
        oldClass = "dark-mode";
        newClass = "light-mode";
      } else {
        darkMode = true;
        oldClass = "light-mode";
        newClass = "dark-mode";
      }
    }
    //change css classes
    for (let i = 0; i < len; i++) {
      allElms[i].classList.remove(oldClass);
      allElms[i].classList.add(newClass);
    }
    //body must be completed sepratley
    body.classList.remove(oldClass);
    body.classList.add(newClass);
  }

  function isWhitespace(s) {
    return /\s/.test(s);
  }

  function isNotWhitespace(s) {
    return !isWhitespace(s);
  }

  function capitalizeFirstLetter(s) {
    return s[0].toUpperCase() + s.slice(1, s.length);
  }

  //draw test canvas
  drawBNGL('Grb2(SH2,SH3!1).Sos(dom!1)', testCanvas);

  //draw bngl
  function drawBNGL(bngl, canvas) {
    //set up drawing context. "willReadFrequently: true" puts processes in GPU
    let ctx = canvas.getContext("2d", { willReadFrequently: true });
    var drawObj = new Graphic(bngl, "compact", darkMode);
    drawObj.draw(ctx, 0, 0);
    //draw graphic
    drawObj.doDrawList();
    let dims = getCanvasDimentions(ctx);
    //resize canvas
    canvas.width = dims[0];
    canvas.height = dims[1];
    //have to redraw
    drawObj.doDrawList();
  }

  //remove item from array
  function arrayRemove(arr, value) {
    var index = arr.indexOf(value);
    if (index > -1) {
      arr.splice(index, 1);
    }
    return arr;
  }

  function standardizeElm(elm) {
    //create new html element for string inputs
    if (typeof elm == "string") {
      newP = document.createElement("p");
      newP.innerHTML = elm;
      elm = newP;
    }
    return elm;
  }

  function addElmLast(child, parent) {
    parent.appendChild(standardizeElm(child));
  }

  function addToTable(elmNestedList, table, colSpan=0) {
    //iterate through rows
    for (let rowNum = 0; rowNum < elmNestedList.length; rowNum++) {
      let row = elmNestedList[rowNum];
      //make new row
      let tempRow = document.createElement("tr");
      tempRow.classList.add("canvas-row");
      addElmLast(tempRow, table);
      //iterate though elements in row
      for (let elmNum = 0; elmNum < row.length; elmNum++) {
        let elm = standardizeElm(row[elmNum]);
        //insert elm into row
        let tempTD = document.createElement("td");
        if (colSpan) {
          tempTD.colSpan = colSpan;
        }
        if (colSpan) {
          tempTD.classList.add("divider-td");
        } else {
          tempTD.classList.add("main-td");
        }
        addElmLast(elm, tempTD);
        addElmLast(tempTD, tempRow);
      }
    }
  }

  //next occurance of char in string
  function nextOccur(string, index, boolExpr, backwards = false, mod = 0) {
    let len = string.length;
    let direction;
    if (backwards) {
      direction = -1;
    } else {
      direction = 1;
    }
    while (index < len && index >= 0) {
      if (boolExpr(string[index])) {
        return index + mod;
      }
      index += direction;
    }
    return ((backwards) ? -1: len);
  }

  //might need to add case for when comment immdiatley follows conc
  //^ I do, see toy1 (1).bngl
  function extractSingleLineBNGL(s, type="") {
    //initialize vars
    let c = 0;
    let len = s.length;
    let char = null;
    let bnglStart = null;
    let bnglEnd = null;
    let concStart = null;
    let concEnd = null;
    let commStart = null;
    let commEnd = null;
    let readType = ((type == "observable") ? false : true);
    //parse
    while (c < len) {
      char = s[c];
      //is comment
      if (char == "#") {
        commStart = c;
        commEnd = len - 1;
        break;
      }
      //starts with number
      if ((bnglStart == null) && (!isNaN(parseFloat(char)))) {
        c = nextOccur(s, c, isWhitespace);
        continue;
      }
      //is whitespace
      if (isWhitespace(char)) {
        c = nextOccur(s, c, isNotWhitespace);
        continue;
      }
      //is observable type
      if ((!readType) && (!bnglEnd) && isNotWhitespace(char) && (char != "#")) {
        readType = true;
        c = nextOccur(s, c, isWhitespace);
        continue;
      }
      //is non-whitespace and non-comment
      if ((!bnglEnd) && isNotWhitespace(char) && (char != "#")) {
        bnglStart = c;
        c = nextOccur(s, c, isWhitespace, false, -1);
        bnglEnd = c;
        c++;
        continue;
      }
      //start concentration
      if (bnglEnd && isNotWhitespace(char) && (char != "#")) {
        concStart = c;
        c = nextOccur(s, c, isWhitespace, false, -1);
        concEnd = c;
      }
      //if at end
      if (c == len - 1) {
        break;
      }
      c++;
    }
    let bngl = s.slice(bnglStart, bnglEnd + 1);
    let conc = s.slice(concStart, concEnd + 1);
    let comment = s.slice(commStart, commEnd + 1);
    console.log(comment);
    return [
      ((bnglStart == null) ? "" : bngl),
      ((concStart == null) ? "" : conc),
      ((commStart == null) ? "" : comment),
    ];
  }

  function extractSingleLineReaction(s) {
    //initialize vars
    let c = 0;
    let len = s.length;
    let char;
    let bngls = [];
    let concs = [];
    let comment = "";
    //parse
    while (c < len) {
      char = s[c];
      //is comment
      if (char == "#") {
        comment = s.slice(c + 1, len);
        break;
      }
      //starts with number
      if ((bngls.length == 0) && (!isNaN(parseFloat(char)))) {
        c = nextOccur(s, c, isWhitespace);
        continue;
      }
      //is whitespace
      if (isWhitespace(char)) {
        c = nextOccur(s, c, isNotWhitespace);
        continue;
      }
      //is non-whitespace and non-comment
      if ((bngls.length == 0) && isNotWhitespace(char) && (char != "#")) {
        let n = nextOccur(s, c, isWhitespace, false, -1);
        bngls.push(s.slice(c, n + 1));
        c = n + 1;
        continue;
      }
      //start concentration
      if ((bngls.length != 0) && isNotWhitespace(char) && (char != "#")) {
        let n = nextOccur(s, c, isWhitespace, false, -1);
        concs.push(s.slice(c, n + 1));
        c = n;
      }
      //if at end
      if (c == len - 1) {
        break;
      }
      c++;
    }
    return [
      bngls.toString(),
      concs.toString(),
      comment
    ];
  }

  //extract bngl element
  function extractBNGL(bnglStr, elmStrList, type="") {
    let bngls = [];
    let toDelete = [];
    for (let i = 0; i < elmStrList.length; i++) {
      let elmStr = elmStrList[i];
      let beginToken = "begin " + elmStr;
      let startIndex = bnglStr.indexOf(beginToken);
      if (startIndex >= 0) {
        //find first new line
        let nlDist = 0;
        while (bnglStr[startIndex + beginToken.length + nlDist] != "\n") {
          nlDist += 1;
        }
        //split by line
        let endIndex = bnglStr.indexOf("\n" + "end " + elmStr);
        let sliced = bnglStr.slice(
          startIndex + nlDist + beginToken.length + 1,
          endIndex
        );
        bngls = bngls.concat(sliced.split("\n"));
        //do actual extraction for each line
        for (let u = 0; u < bngls.length; u++) {
          let bnglConcPair;
          if (type == "reaction") {
            bnglConcPair = extractSingleLineReaction(bngls[u]);
          } else {
            bnglConcPair = extractSingleLineBNGL(bngls[u], type);
          }
          bngls[u] = bnglConcPair;
          //mark empty strings for deletion
          let isEmpty = true;
          let onlyComment = false;
          for (let y = 0; y < bnglConcPair.length; y++) {
            //if string has content
            if (bnglConcPair[y].trim()) {
              //if comment is only content
              if (y == 2) {
                isEmpty = false;
                onlyComment = true;
              } else {
                //if there is non comment content
                isEmpty = false;
              }
              break;
            }
          };
          if (isEmpty) {
            toDelete.push(bngls[u]);
          }
          if (onlyComment) {
            bngls[u] = bngls[u][2];
          }
        }
        //if begin token not found
        } else {
          continue;
        }
      }
      //delete empty strings
      for (let u = 0; u < toDelete.length; u++) {
        arrayRemove(bngls, toDelete[u]);
      }
      return bngls;
  }

  //render one set (need to add compartments)
  function prepareRow(bnglConcPair, title, includeConc=false) {
    let bngl, conc, comment;
    [bngl, conc, comment] = bnglConcPair;
    bngl = bngl.trim();
    conc = conc.trim();
    comment = comment.trim();
    //add paranthesis if there are none
    if (bngl.indexOf("(") < 0) {
      bngl = bngl + "()";
    }
    //get name (change this to only after parenthesis)
    let name = bngl.split("(")[0];
    //create new canvas
    const newCan = document.createElement("canvas");
    newCan.id = title;
    //must have inital dimensions as large as largest possible visualization
    newCan.width = "500";
    newCan.height = "180";
    newCan.classList.add("bngl-canvas");
    //draw object on canvas
    drawBNGL(bngl, newCan);
    //output as list
    if (includeConc) {
      return [name, newCan, bngl, conc, comment];
    } else {
      return [name, newCan, bngl, "", comment];
    }
  }

  //render 1 type (molecules, species, etc)
  function visualizeType(type, list) {
    //render header
    addToTable([[document.createElement("hr")]], canvTable, 5);
    const newDivider = document.createElement("p");
    newDivider.innerHTML = capitalizeFirstLetter(type);
    newDivider.classList.add("table-divider");
    addToTable([[newDivider]], canvTable, 5);
    if (type == "observables") {
      addToTable(
        [['Type', 'Name', 'Visualization', 'BNGL code', 'Comment']],
        canvTable
      );

    } else {
      addToTable(
        [['Name', 'Visualization', 'BNGL code', 'Concentration', 'Comment']],
        canvTable
      );
    }
    //render rows
    if (list.length > 0) {
      let output = [];
      for (let i = 0; i < list.length; i++) {
        item = list[i];
        if (typeof item == "object") {
          output.push(prepareRow(item, type + i, true));
        } else if (typeof item == "string") {
          addToTable([[item]], canvTable, 5);
        }
      }
      addToTable(output, canvTable);
    } else {
      addToTable([["None", "", "", ""]], canvTable);
    }
  }

  //render everything in bngl
  function visualize() {
    //remove all old visualizations
    let fileHasChanged = fileInput.value != oldFileInputValue;
    oldFileInputValue = fileInput.value;
    //remove everything in table
    let oldElms = canvTable.children;
    let numOldElms = oldElms.length;
    for(let i = 0; i < numOldElms; i++) {
      oldElms[0].remove();
    }
    //remove everything in canvas div
    oldElms = canvContain.children;
    numOldElms = oldElms.length;
    for(let i = 0; i < numOldElms; i++) {
      oldElms[0].remove();
    }
    var bnglFile = fileInput.files[0];
    reader = new FileReader();
    reader.onload = () => {
      let bngl = reader.result;
      //process all things of intrest
      molecules = extractBNGL(bngl, moleculeTokens);
      species = extractBNGL(bngl, speciesTokens);
      observables = extractBNGL(bngl, observablesTokens, "observable");
      //reactions = extractBNGL(bngl, reactionTokens, "reaction");
      reactions = [];
      //visualize everything
      visualizeType("molecules", molecules);
      visualizeType("species", species);
      visualizeType("observables", observables);
      visualizeType("reactions", reactions);
    }
    //read if file present
    if (fileInput.value) {
      reader.readAsText(bnglFile);
    }
  }
</script>
