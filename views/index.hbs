<p><h1>BioNetGenLanguage (BNGL) code visualizer</h1></p>
<table>
  <tr>
    <td>
      <input id="bngl-file-input" type="file" onchange="visualize()">
    </td>
    <td id="canvas-cell">
      <canvas id="testCanvas" width="500" height="180"></canvas>
    </td>
    <td id="canvas-text">
      Molecule is shown as an oval ...
    </td>
  </tr>
</table>
<div id="canvas-container"></div>
<div id="table-container"></div>
<script src="/model-graphics.js"></script>
<script>
  //set bngl begin tokens
  const moleculeTokens = ["molecule types", "molecular types"];
  const speciesTokens = ["species", "seed species"];
  const observablesTokens = ["observables"];
  const reactionTokens = ["reaction rules"];

  //get major elements
  const testCanvas = document.getElementById("testCanvas");
  const canvContain = document.getElementById("canvas-container");
  const tableContain = document.getElementById("table-container");
  const fileInput = document.getElementById("bngl-file-input");
  const body = document.body;

  //other global var declaration
  var oldFileInputValue = "";
  var allElms;
  //map from molecule bngl string to molecule graphics class instance
  var moleculeMap = {};

  //set mode to dark mode initially
  var darkMode = true;
  switchDarkMode(false);

  function switchDarkMode(actuallySwitch = true) {
    //recompile list of elms
    allElms = body.getElementsByTagName("*");
    let len = allElms.length;
    let oldClass, newClass;
    //switch mode
    if (actuallySwitch) {
      if (darkMode) {
        darkMode = false;
        oldClass = "dark-mode";
        newClass = "light-mode";
      } else {
        darkMode = true;
        oldClass = "light-mode";
        newClass = "dark-mode";
      }
    }
    //change css classes
    for (let i = 0; i < len; i++) {
      allElms[i].classList.remove(oldClass);
      allElms[i].classList.add(newClass);
    }
    //body must be completed sepratley
    body.classList.remove(oldClass);
    body.classList.add(newClass);
  }

  function isWhitespace(s) {
    return /\s/.test(s);
  }

  function isNotWhitespace(s) {
    return !isWhitespace(s);
  }

  function capitalizeFirstLetter(s) {
    return s[0].toUpperCase() + s.slice(1, s.length);
  }

  //draw test canvas
  drawBNGL('Grb2(SH2,SH3!1).Sos(dom!1)', testCanvas);

  //draw bngl
  function drawBNGL(bngl, canvas, type = "") {
    //get parent for observables
    let parent = ((type == "placeholder") ? moleculeMap[placeholder] : null)
    //set up drawing context. "willReadFrequently: true" puts processes in GPU
    let ctx = canvas.getContext("2d", { willReadFrequently: true });
    var drawObj = new Graphic(bngl, "compact", darkMode, parent);
    drawObj.draw(ctx, 0, 0);
    //draw graphic
    drawObj.doDrawList();
    let dims = getCanvasDimentions(ctx);
    //resize canvas
    canvas.width = dims[0];
    canvas.height = dims[1];
    //have to redraw
    drawObj.doDrawList();
    if (type == "molecules") {
      moleculeMap[bngl] = drawObj;
    }
  }

  //remove item from array
  function arrayRemove(arr, value) {
    var index = arr.indexOf(value);
    if (index > -1) {
      arr.splice(index, 1);
    }
    return arr;
  }

  function standardizeElm(elm) {
    //create new html element for string inputs
    if (typeof elm == "string") {
      newP = document.createElement("p");
      newP.innerHTML = elm;
      elm = newP;
    }
    return elm;
  }

  function addElmLast(child, parent) {
    parent.appendChild(standardizeElm(child));
  }

  function addToTable(elmNestedList, table, colSpan=0) {
    //iterate through rows
    for (let rowNum = 0; rowNum < elmNestedList.length; rowNum++) {
      let row = elmNestedList[rowNum];
      //make new row
      let tempRow = document.createElement("tr");
      tempRow.classList.add("canvas-row");
      addElmLast(tempRow, table);
      //iterate though elements in row
      for (let elmNum = 0; elmNum < row.length; elmNum++) {
        let elm = standardizeElm(row[elmNum]);
        //insert elm into row
        let tempTD = document.createElement("td");
        if (colSpan) {
          tempTD.colSpan = colSpan;
        }
        if (colSpan) {
          tempTD.classList.add("divider-td");
        } else {
          tempTD.classList.add("main-td");
        }
        addElmLast(elm, tempTD);
        addElmLast(tempTD, tempRow);
      }
    }
  }

  //next occurance of char in string
  function nextOccur(string, index, boolExpr, backwards = false, mod = 0) {
    let len = string.length;
    let direction;
    if (backwards) {
      direction = -1;
    } else {
      direction = 1;
    }
    while (index < len && index >= 0) {
      if (boolExpr(string[index])) {
        return index + mod;
      }
      index += direction;
    }
    return ((backwards) ? -1: len);
  }

  class BNGLExtractor {
    constructor(numOutputs) {
      //next free index in this.outputs
      this.freeIndex = 0;
      //list of objects, see addCheck()
      this.checks = [];
      //list of output strings
      this.outputs = [];
      //map of output indecies and wether they have been evaluated
      this.outputEvaluations = {};
      //map of identifier strings to this.output indexes
      this.identifiers = {};
      //initialize lists and objects
      for (let i = 0; i < numOutputs; i++) {
        this.outputs.push("");
        this.outputEvaluations[i] = false;
      }
    }

    getOutputIndex(id) {
      return this.identifiers[id];
    }

    addIdentifier(id) {
      if (this.identifiers[id]) {
        throw new Error('identifier ' + id + ' already used');
      } else {
        this.identifiers[id] = this.freeIndex;
      }
      this.freeIndex++;
    }

    addCheck(boolExpr, id, startIndex, endIndex, nextIndex, loopType, evalIndexList) {
      let outputIndex = this.getOutputIndex(id);
      this.checks.push(
        {
          //function: see evaluateBoolExpr()
          "boolExpr": boolExpr,
          //string: unique id for this.outputs
          "id": id,
          //function: (string, stringIndex) => start of output within string
          "startIndex": startIndex,
          //function: (string, stringIndex) => end of output within string
          "endIndex": endIndex,
          //function: (string, stringIndex) => next value of string index
          "nextIndex": nextIndex,
          //string: ("break", "continue", or "none")
          "loopType": loopType,
          //list: list of [string: id, boolean]
          "evalIndexList": evalIndexList,
          //int: index for this.outputs
          "outputIndex": outputIndex
        }
      );
    }

    addStartNumCheck() {
      let f = (paramList)=> {
        let c, char, evalIndexList, outputEvaluations, outputIndex;
        [c, char, evalIndexList, outputEvaluations, outputIndex] = paramList;
        if ((!outputEvaluations[outputIndex]) && (!isNaN(parseFloat(char)))) {
          //return something
        }
      }
      this.addCheck(
        f,
        -1,
        -1,
        -1,
        (s, c) => nextOccur(s, c, isWhitespace),
        "continue",
        [["bngl", false]]
      );
    }

    evaluateBoolExpr(boolExpr, c, char, evalIndexList, outputIndex) {
      return boolExpr([
        c,
        char,
        evalIndexList,
        this.outputEvaluations,
        outputIndex
      ]);
    }

    process(s) {
      //initialize vars
      let c = 0;
      let len = s.length;
      let char = null;
      let checks = this.checks;
      let checksLen = checks.length;
      //parse
      while (c < len) {
        char = s[c];
        for (let i = 0; i < checksLen; i ++) {
          let check = checks[i];
          let boolExpr = check.boolExpr;
          let id = check.id;
          let startIndex = check.startIndex;
          let endIndex = check.endIndex;
          let nextIndex = check.nextIndex;
          let loopType = check.loopType;
          let evalIndexList = check.evalIndexList;
          let outputIndex = check.outputIndex;
          this.evaluateBoolExpr(
            boolExpr,
            c,
            char,
            evalIndexList,
            outputIndex
          );
        }
      }
    }
  }

  //might need to add case for when comment immdiatley follows conc
  //^ I do, see toy1 (1).bngl
  function extractSingleLineBNGL(s, type="") {
    //initialize vars
    let c = 0;
    let len = s.length;
    let char;
    let bngl, conc, comm, observType;
    let readType = ((type == "observable") ? false : true);
    //parse
    while (c < len) {
      char = s[c];
      //is comment
      if (char == "#") {
        comm = s.slice(c, len);
        break;
      }
      //starts with number
      if ((!bngl) && (!isNaN(parseFloat(char)))) {
        c = nextOccur(s, c, isWhitespace);
        continue;
      }
      //is whitespace
      if (isWhitespace(char)) {
        c = nextOccur(s, c, isNotWhitespace);
        continue;
      }
      //is observable type
      if ((!readType) && (!bngl) && isNotWhitespace(char) && (char != "#")) {
        let n = nextOccur(s, c, isWhitespace);
        observType = s.slice(c, n);
        readType = true;
        c = n;
        continue;
      }
      //is non-whitespace and non-comment
      if ((!bngl) && isNotWhitespace(char) && (char != "#")) {
        let n = nextOccur(s, c, isWhitespace, false, -1);
        bngl = s.slice(c, n + 1);
        c = n + 1;
        continue;
      }
      //start concentration
      if (bngl && isNotWhitespace(char) && (char != "#")) {
        let n = nextOccur(s, c, isWhitespace, false, -1);
        conc = s.slice(c, n + 1);
        c = n;
      }
      //if at end
      if (c == len - 1) {
        break;
      }
      c++;
    }
    return [
      ((bngl == null) ? "" : bngl),
      ((conc == null) ? "" : conc),
      ((comm == null) ? "" : comm),
      ((observType == null) ? "" : observType),
    ];
  }

  function extractSingleLineReaction(s) {
    //initialize vars
    let c = 0;
    let len = s.length;
    let char;
    let bngls = [];
    let concs = [];
    let comment = "";
    //parse
    while (c < len) {
      char = s[c];
      //is comment
      if (char == "#") {
        comment = s.slice(c + 1, len);
        break;
      }
      //starts with number
      if ((bngls.length == 0) && (!isNaN(parseFloat(char)))) {
        c = nextOccur(s, c, isWhitespace);
        continue;
      }
      //is whitespace
      if (isWhitespace(char)) {
        c = nextOccur(s, c, isNotWhitespace);
        continue;
      }
      //is non-whitespace and non-comment
      if ((bngls.length == 0) && isNotWhitespace(char) && (char != "#")) {
        let n = nextOccur(s, c, isWhitespace, false, -1);
        bngls.push(s.slice(c, n + 1));
        c = n + 1;
        continue;
      }
      //start concentration
      if ((bngls.length != 0) && isNotWhitespace(char) && (char != "#")) {
        let n = nextOccur(s, c, isWhitespace, false, -1);
        concs.push(s.slice(c, n + 1));
        c = n;
      }
      //if at end
      if (c == len - 1) {
        break;
      }
      c++;
    }
    return [
      bngls.toString(),
      concs.toString(),
      comment
    ];
  }

  //extract bngl element
  function extractBNGL(bnglStr, elmStrList, type="") {
    let bngls = [];
    let toDelete = [];
    for (let i = 0; i < elmStrList.length; i++) {
      let elmStr = elmStrList[i];
      let beginToken = "begin " + elmStr;
      let startIndex = bnglStr.indexOf(beginToken);
      if (startIndex >= 0) {
        //find first new line
        let nlDist = 0;
        while (bnglStr[startIndex + beginToken.length + nlDist] != "\n") {
          nlDist += 1;
        }
        //split by line
        let endIndex = bnglStr.indexOf("\n" + "end " + elmStr);
        let sliced = bnglStr.slice(
          startIndex + nlDist + beginToken.length + 1,
          endIndex
        );
        bngls = bngls.concat(sliced.split("\n"));
        //do actual extraction for each line
        for (let u = 0; u < bngls.length; u++) {
          let bnglConcPair;
          if (type == "reaction") {
            bnglConcPair = extractSingleLineReaction(bngls[u]);
          } else {
            bnglConcPair = extractSingleLineBNGL(bngls[u], type);
          }
          bngls[u] = bnglConcPair;
          //mark empty strings for deletion
          let isEmpty = true;
          let onlyComment = false;
          for (let y = 0; y < bnglConcPair.length; y++) {
            //if string has content
            if (bnglConcPair[y].trim()) {
              //if comment is only content
              if (y == 2) {
                isEmpty = false;
                onlyComment = true;
              } else {
                //if there is non comment content
                isEmpty = false;
              }
              break;
            }
          };
          if (isEmpty) {
            toDelete.push(bngls[u]);
          }
          if (onlyComment) {
            bngls[u] = bngls[u][2];
          }
        }
        //if begin token not found
        } else {
          continue;
        }
      }
      //delete empty strings
      for (let u = 0; u < toDelete.length; u++) {
        arrayRemove(bngls, toDelete[u]);
      }
      return bngls;
  }

  function addBNGLParenthesis(bngl) {
    //split into each molecule
    let molecules = bngl.split(".");
    let output = "";
    let len = molecules.length;
    molecules.forEach((m, i) => {
      //add paranthesis if there are none
      if (m.indexOf("(") < 0) {
        m = m + "()";
      }
      output += m;
      if (i != len - 1) {
        output += ".";
      }
    });
    return output;
  }

  //render one set (need to add compartments)
  function prepareRow(bnglConcPair, type) {
    let bngl, conc, comment;
    [bngl, conc, comment, observType] = bnglConcPair;
    comment = comment.trim();
    bngl = bngl.trim();
    conc = conc.trim();
    observType = observType.trim();
    if (type == "observables") {
      let temp;
      temp = bngl;
      bngl = conc;
      conc = temp;
      name = conc;
    }
    //add paranthesis if there are none
    bngl = addBNGLParenthesis(bngl);
    //get name (change this to only after parenthesis)
    if (type != "observables") {
      let name = bngl.split("(")[0];
    }
    //create new canvas
    const newCan = document.createElement("canvas");
    //must have inital dimensions as large as largest possible visualization
    newCan.width = "500";
    newCan.height = "180";
    newCan.classList.add("bngl-canvas");
    //draw object on canvas
    drawBNGL(bngl, newCan, type);
    //output as list
    if (type == "species") {
      return [name, newCan, bngl, conc, comment];
    } else if (type == "observables") {
      return [observType, name, newCan, bngl, comment];
    } else {
      return [name, newCan, bngl, comment];
    }
  }

  //render 1 type (molecules, species, etc)
  function visualizeType(type, list) {
    //add new table
    let newTable = document.createElement("table");
    addElmLast(newTable, tableContain);
    //render header
    addToTable([[document.createElement("hr")]], newTable, 5);
    const newDivider = document.createElement("p");
    newDivider.innerHTML = capitalizeFirstLetter(type);
    newDivider.classList.add("table-divider");
    addToTable([[newDivider]], newTable, 5);
    if (type == "observables") {
      addToTable(
        [['Type', 'Name', 'Visualization', 'BNGL code', 'Comment']],
        newTable
      );
    } else if (type == "molecules") {
      addToTable(
        [['Name', 'Visualization', 'BNGL code', 'Comment']],
        newTable
      );
    } else {
      addToTable(
        [['Name', 'Visualization', 'BNGL code', 'Concentration', 'Comment']],
        newTable
      );
    }
    //render rows
    if (list.length > 0) {
      let output = [];
      for (let i = 0; i < list.length; i++) {
        item = list[i];
        //normal row
        if (typeof item == "object") {
          output.push(prepareRow(item, type));
        }
        //full line comment
        else if (typeof item == "string") {
          addToTable([[item]], newTable, 5);
        }
      }
      addToTable(output, newTable);
    } else {
      addToTable([["None", "", "", ""]], newTable);
    }
  }

  //render everything in bngl
  function visualize() {
    //remove all old visualizations
    let fileHasChanged = fileInput.value != oldFileInputValue;
    oldFileInputValue = fileInput.value;
    //remove everything in table
    let oldElms = tableContain.children;
    let numOldElms = oldElms.length;
    for(let i = 0; i < numOldElms; i++) {
      oldElms[0].remove();
    }
    //remove everything in canvas div
    oldElms = canvContain.children;
    numOldElms = oldElms.length;
    for(let i = 0; i < numOldElms; i++) {
      oldElms[0].remove();
    }
    var bnglFile = fileInput.files[0];
    reader = new FileReader();
    reader.onload = () => {
      let bngl = reader.result;
      //process all things of intrest
      molecules = extractBNGL(bngl, moleculeTokens);
      species = extractBNGL(bngl, speciesTokens);
      observables = extractBNGL(bngl, observablesTokens, "observable");
      //reactions = extractBNGL(bngl, reactionTokens, "reaction");
      reactions = [];
      //visualize everything
      visualizeType("molecules", molecules);
      visualizeType("species", species);
      visualizeType("observables", observables);
      visualizeType("reactions", reactions);
    }
    //read if file present
    if (fileInput.value) {
      reader.readAsText(bnglFile);
    }
  }
</script>
